# 重排九宫自动解密(8-tile puzzle solver)
An automatic 8-tile puzzle solver, using A algorithm. 
[![应用使用说明](https://i.postimg.cc/P5GcYB7y/image.png)](https://postimg.cc/0bfcqHPK)

# 代码简单说明
## 生成九宫排列
用户可采取两种方式生成初始九宫排列。第一是，自己输入一个九宫排列：程序会按照用户输入的信息生成一个3*3的矩阵。第二是，随机生成一个九宫排列：本程序会随机生成一个0~8，3*3的矩阵。

## 判定目标状态
有了初始状态后，就要判定出目标状态。一共有两种可能：目标状态为{{1,2,3},{8,0,4},{7,6,5}}或目标状态为{{2,1,3},{8,0,4},{7,6,5}}。为了判定哪个目标状态是该初始状态所对应的目标状态，首先要计算初始状态中倒置的个数。此处倒置是指一个数字出现在一个小于它的数字之前。例如：{1,2,3,4,8,6,7,5}的数组有8-6、8-7、8-5、6-5、7-5、共5个倒置。如果某初始状态矩阵之中的倒置个数为偶数，其对应的目标状态就是第一个形式。如果倒置个数为奇数，其对应的目标状态就是第二个形式。
为了方便计算某个矩阵中的倒置个数，本程序先将矩阵专程为数组，然后再取倒置个数。

## 节点数据结构的设计
节点是本程序算法的中心，所以为了解释本程序使用的算法，首先要讨论本程序中节点结构的设计（请参考node.h/node.cpp）。节点（Node）结构共有六个变量，它们分别为：本节点的父辈、本节点的九宫排列、本节点的h值、本节点的深度、本节点九宫排列中空格的坐标位置。为了方便利用节点中的矩阵（九宫排列），加之设计了复制矩阵、判定两个矩阵是否一致、将矩阵转成为数组、取空格坐标位置等的函数。

## 采取A算法求解
本程序采用了A算法获得最终的目标节点。
（1）将初始状态放在一个称open的priority_queue容器中。该容器是按节点的成本（请见以下关于节点成本的说明）从小到大排序。另外，生成一个称closed的空表。
（2）取open表中最前的结点，称为BestNode。
（3）若BestNode已在closed表中出现且其成本高于或等于closed表中节点的成本，则返回（2）。若BestNode已在closed表中出现但其成本低于closed表中节点的成本，则将closed表中的节点从closed表中删除，并且对BestNode继续进行以下过程。
（4）若BestNode是目标节点，即其h值为零，则返回BestNode，算法完成，结束算法。
（5）对BestNode进行如下的扩展过程
	（a）逐个研究BestNode矩阵中的空格向上、下、左或右四个方向移动一个格子之后产生的矩阵。
	（b）检查移动的方向是否合格，即移动空格后，空格是否出界。若非合格，则返回（5.a）。
	（c）用新的矩阵生成一个新节点，并且计算其深度与h值。将新节点放入open表中。
（6）返回（2）。

## 节点成本算法
节点的成本由两个项而构成的，它们是节点的深度与节点的h值。
深度的计算较简单，设根节点的深度为0。任何节点的深度是其祖辈节点的深度加一。
	h值的数学函数形式为h(n)=P(n)+3S(n)，其中P(i)是每一张牌i当前位置与其在目标状态中位置的曼哈顿距离，所有P(i)之和是P(n)。S(i)是对于非中心位置的牌i，顺着一个方向（此：顺时方向）检查其后面的牌是否和目标状态中相应牌之间顺序一致。如果不一致，则给分数2，否则给分数0。若中心牌不是空格，给分1，若是空格，给分0。所有S(i)之和是S(n)。
	计算P(n)算法的实现相当简单，首先找牌i在当前节点矩阵中与在目标状态中的位置，然后求它们之间的曼哈顿距离。
	为了方便计算S(n)，首先将当前节点矩阵转成为一个数组，然后检查数组中第i+1项的值是否等于第i项的值加一。若是，则给分数0，否则给分数2。如果目标状态是{1,2,3}形式，则只需要对8牌进行特殊处理。如果目标状态是{2,1,3}形式，则需要对8、1、2牌进行特殊处理。
	最后检查矩阵中心位置的值是否是0。若是给分数0，否则给分数1。	

## 打印结果
本程序采用了递归方式，找到扩展树的根节点，并且按用户设置的速度逐一地输出从根节点一直到最终目标节点对应的九宫排列。

Note: May need to run the .exe file through the Qt application.
